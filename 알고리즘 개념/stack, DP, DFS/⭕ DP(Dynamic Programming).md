# ⭕ DP(Dynamic Programming)

---

- 재귀(recursive)로 짠 함수들의 경우 n이 커질수록 불필요하게 반복되는 연산이 매우 많아짐(시간복잡도↑)  
- 따라서 이를 줄이기 위해 memoization을 활용하여 이러한 불필요한 연산을 줄이는 방식으로 DP라 한다.

---

#### ✅ ex

```python
# 대표적인 재귀함수인 피보나치 함수
arr = [0, 1]

def fibo(n):
    if n >= 2 and len(arr) <= n:
        arr.append(fibo(n-1) + fibo(n-2))
    return arr[n]

print(fibo(20))


############# DP를 활용한 피보나치 ##################


memo2 = [-1] * 21 # 미리 할당
memo2[0] = 0 # 초기값 설정
memo2[1] = 1 # 초기값 설정

def fibo2(n): 
    if memo2[n] == -1: # 초기값 설정 -1이 아니면
        memo2[n] = fibo2(n-1) + fibo2(n-2) # 메모리에 재귀함수로 할당
    return memo2[n] # 출력은 메모리로!

print(fibo2(10)) # 재귀함수 값 확인
print(memo2) # 메모리의 변동을 확인함
```

---

- 동적 계획(DP) 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

---

# ⭕ DFS(Depth First Search, 깊이 우선 탐색)

---

- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함.
- 두 가지 방법 
  - DFS, 깊이 우선 탐색
  - BFS, 너비 우선 탐색
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회 방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 `후입선출 구조의 스택` 활용 
- 현실세계의 문제를 프로그래밍으로 해결하려는 시도가 많음. `정렬, 탐색` 일 확률이 높음  
- 특정 값을 탐색하고 싶은 경우

---

1. 시작 정점 v를 결정하여 방문한다.

2. 정점 v에 인접한 정점 중에서

   1) 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방묺나다. 그리고 w를 v로 하여 다시 2)를 반복한다.

   2) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다.

3. 스택이 고백이 될 때까지 2)를 반복한다.

---

#### ✅ DFS 개요

```
visited[], stack[] 초기화
DFS v
	v 방문;
	visited[v] <- true;
	do {
		if ( v의 인접 정점 중 방문 안한 w 찾기)
			push(v);
		while(w) {
			w 방문;
			visited[w] <- true;
			push(w);
			v<-w;
			v의 인접 정점 중 방문 안한 w찾기
		}
		v<-pop(stack)
	} while(v)
end DFS()
```

### DFS는 방문 체크가 제일 중요하다. (모든 곳에 방문하는데 의의를 두고 있음) 여기서 우선운위가 정해진다면 경로가 달라지긴 하지만, 결국에는 모든 곳에 방문 한다는 것은 달라지지 않는다.

#### ✅ DFS 알고리즘 -재귀

```
DFS_Recursive(G, v)
	visited[v] <- true // v 방문 설정
	
	FOR each all w in adjacency(G, v);
		IF visited[w] != True
			DFS_Recursive(G, w)
```

### 재귀적으로 돌면서 방문 기록을 남긴다. 계속 반복 DP를 아마 활용할  수 있을 듯?

#### ✅ DFS 알고리즘 -반복

```
STACK s
visited[ ]
DFS(v)
	push(s, v)
	WHILE NOT isEmpty( s )
		v <- pop(s)
		IF NOT visited[v]
			visit(v)
			FOR each w in adjacency( v )
				IF NOT visited[w]
					push(s, w)
```

---

# ⭕ BFS(Breath First Search, 너비 우선 탐색)

---

- 가까운 노드부터 탐색하는 알고리즘
- 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되는 성질을 이용하여 가까운 노드부터 탐색
- 자세한 동작 방식
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
  2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
  3.  2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.







 